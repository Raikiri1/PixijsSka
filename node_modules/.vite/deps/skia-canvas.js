import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports, module) {
    "use strict";
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
          code = path.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i);
            else
              res = path.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path;
          if (i >= 0)
            path = arguments[i];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute) path = ".";
        if (path.length > 0 && trailingSeparator) path += "/";
        if (isAbsolute) return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to) return "";
        from = posix.resolve(from);
        to = posix.resolve(to);
        if (from === to) return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0) return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path.length - 1; i >= 1; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1) return hasRoot ? "/" : ".";
        if (hasRoot && end === 1) return "//";
        return path.slice(0, end);
      },
      basename: function basename(path, ext) {
        if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
          if (ext.length === path.length && ext === path) return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end) end = firstNonSlashEnd;
          else if (end === -1) end = path.length;
          return path.slice(start, end);
        } else {
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1) return "";
          return path.slice(start, end);
        }
      },
      extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0) return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
            else ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute) ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix.posix = posix;
    module.exports = posix;
  }
});

// node_modules/skia-canvas/lib/browser.js
var require_browser = __commonJS({
  "node_modules/skia-canvas/lib/browser.js"(exports, module) {
    var import_path = __toESM(require_path_browserify());
    var _toURL_ = Symbol.for("toDataURL");
    var loadImage = (src) => {
      let img = Object.assign(new Image(), { crossOrigin: "Anonymous", src });
      return img.decode().then(() => img);
    };
    var loadImageData = (src, width, height, settings) => fetch(src).then((resp) => resp.arrayBuffer()).then((buf) => new ImageData(new Uint8ClampedArray(buf), width, height, settings));
    var Canvas = class {
      constructor(width, height) {
        let elt = document.createElement("canvas"), pages = [];
        Object.defineProperty(elt, "async", { value: true, writable: false, enumerable: true });
        for (var [prop, get] of Object.entries({
          png: () => asBuffer(elt, "image/png"),
          jpg: () => asBuffer(elt, "image/jpeg"),
          pages: () => pages.concat(elt).map((c) => c.getContext("2d"))
        })) Object.defineProperty(elt, prop, { get });
        return Object.assign(elt, {
          width,
          height,
          newPage(...size) {
            var { width: width2, height: height2 } = elt, page = Object.assign(document.createElement("canvas"), { width: width2, height: height2 });
            page.getContext("2d").drawImage(elt, 0, 0);
            pages.push(page);
            var [width2, height2] = size.length ? size : [width2, height2];
            return Object.assign(elt, { width: width2, height: height2 }).getContext("2d");
          },
          saveAs(filename, args) {
            args = typeof args == "number" ? { quality: args } : args;
            let opts = exportOptions(this.pages, { filename, ...args }), { pattern, padding, mime, quality, matte, density, archive } = opts, pages2 = atScale(opts.pages, density);
            return padding == void 0 ? asDownload(pages2[0], mime, quality, matte, filename) : asZipDownload(pages2, mime, quality, matte, archive, pattern, padding);
          },
          toBuffer(extension = "png", args = {}) {
            args = typeof args == "number" ? { quality: args } : args;
            let opts = exportOptions(this.pages, { extension, ...args }), { mime, quality, matte, pages: pages2, density } = opts, canvas = atScale(pages2, density, matte)[0];
            return asBuffer(canvas, mime, quality, matte);
          },
          [_toURL_]: elt.toDataURL.bind(elt),
          toDataURL(extension = "png", args = {}) {
            args = typeof args == "number" ? { quality: args } : args;
            let opts = exportOptions(this.pages, { extension, ...args }), { mime, quality, matte, pages: pages2, density } = opts, canvas = atScale(pages2, density, matte)[0], url = canvas[canvas === elt ? _toURL_ : "toDataURL"](mime, quality);
            return Promise.resolve(url);
          }
        });
      }
    };
    var Crc32 = class _Crc32 {
      static for(data) {
        return new _Crc32().append(data).get();
      }
      constructor() {
        this.crc = -1;
      }
      get() {
        return ~this.crc;
      }
      append(data) {
        var crc = this.crc | 0, table = this.table;
        for (var offset = 0, len = data.length | 0; offset < len; offset++) {
          crc = crc >>> 8 ^ table[(crc ^ data[offset]) & 255];
        }
        this.crc = crc;
        return this;
      }
    };
    Crc32.prototype.table = (() => {
      var i, j, t, table = [];
      for (i = 0; i < 256; i++) {
        t = i;
        for (j = 0; j < 8; j++) {
          t = t & 1 ? t >>> 1 ^ 3988292384 : t >>> 1;
        }
        table[i] = t;
      }
      return table;
    })();
    function calloc(size) {
      let array = new Uint8Array(size), view = new DataView(array.buffer), buf = {
        array,
        view,
        size,
        set8(at, to) {
          view.setUint8(at, to);
          return buf;
        },
        set16(at, to) {
          view.setUint16(at, to, true);
          return buf;
        },
        set32(at, to) {
          view.setUint32(at, to, true);
          return buf;
        },
        bytes(at, to) {
          array.set(to, at);
          return buf;
        }
      };
      return buf;
    }
    var _Zip = class _Zip {
      constructor(directory) {
        let now = /* @__PURE__ */ new Date();
        Object.assign(this, {
          directory,
          offset: 0,
          files: [],
          time: (now.getHours() << 6 | now.getMinutes()) << 5 | now.getSeconds() / 2,
          date: (now.getFullYear() - 1980 << 4 | now.getMonth() + 1) << 5 | now.getDate()
        });
        this.add(directory);
      }
      async add(filename, blob) {
        let folder = !blob, name = _Zip.encoder.encode(`${this.directory}/${folder ? "" : filename}`), data = new Uint8Array(folder ? 0 : await blob.arrayBuffer()), preamble = 30 + name.length, descriptor = preamble + data.length, postamble = 16, { offset } = this;
        let header = calloc(26).set32(0, 134742036).set16(6, this.time).set16(8, this.date).set32(10, Crc32.for(data)).set32(14, data.length).set32(18, data.length).set16(22, name.length);
        offset += preamble;
        let payload = calloc(preamble + data.length + postamble).set32(0, 67324752).bytes(4, header.array).bytes(30, name).bytes(preamble, data);
        offset += data.length;
        payload.set32(descriptor, 134695760).bytes(descriptor + 4, header.array.slice(10, 22));
        offset += postamble;
        this.files.push({ offset, folder, name, header, payload });
        this.offset = offset;
      }
      toBuffer() {
        let length = this.files.reduce((len, { name: name2 }) => 46 + name2.length + len, 0), cdr = calloc(length + 22), index = 0;
        for (var { offset, name, header, folder } of this.files) {
          cdr.set32(index, 33639248).set16(index + 4, 20).bytes(index + 6, header.array).set8(index + 38, folder ? 16 : 0).set32(index + 42, offset).bytes(index + 46, name);
          index += 46 + name.length;
        }
        cdr.set32(index, 101010256).set16(index + 8, this.files.length).set16(index + 10, this.files.length).set32(index + 12, length).set32(index + 16, this.offset);
        let output = new Uint8Array(this.offset + cdr.size), cursor = 0;
        for (var { payload } of this.files) {
          output.set(payload.array, cursor);
          cursor += payload.size;
        }
        output.set(cdr.array, cursor);
        return output;
      }
      get blob() {
        return new Blob([this.toBuffer()], { type: "application/zip" });
      }
    };
    __publicField(_Zip, "encoder", new TextEncoder());
    var Zip = _Zip;
    var asBlob = (canvas, mime, quality, matte) => {
      if (matte) {
        let { width, height } = canvas, comp = Object.assign(document.createElement("canvas"), { width, height }), ctx = comp.getContext("2d");
        ctx.fillStyle = matte;
        ctx.fillRect(0, 0, width, height);
        ctx.drawImage(canvas, 0, 0);
        canvas = comp;
      }
      return new Promise((res, rej) => canvas.toBlob(res, mime, quality));
    };
    var asBuffer = (...args) => asBlob(...args).then((b) => b.arrayBuffer());
    var asDownload = async (canvas, mime, quality, matte, filename) => {
      _download(filename, await asBlob(canvas, mime, quality, matte));
    };
    var asZipDownload = async (pages, mime, quality, matte, archive, pattern, padding) => {
      let filenames = (i) => pattern.replace("{}", String(i + 1).padStart(padding, "0")), folder = (0, import_path.basename)(archive, ".zip") || "archive", zip = new Zip(folder);
      await Promise.all(pages.map(async (page, i) => {
        let filename = filenames(i);
        await zip.add(filename, await asBlob(page, mime, quality, matte));
      }));
      _download(`${folder}.zip`, zip.blob);
    };
    var _download = (filename, blob) => {
      const href = window.URL.createObjectURL(blob), link = document.createElement("a");
      link.style.display = "none";
      link.href = href;
      link.setAttribute("download", filename);
      if (typeof link.download === "undefined") {
        link.setAttribute("target", "_blank");
      }
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      setTimeout(() => window.URL.revokeObjectURL(href), 100);
    };
    var atScale = (pages, density, matte) => pages.map((page) => {
      if (density == 1 && !matte) return page.canvas;
      let scaled = document.createElement("canvas"), ctx = scaled.getContext("2d"), src = page.canvas ? page.canvas : page;
      scaled.width = src.width * density;
      scaled.height = src.height * density;
      if (matte) {
        ctx.fillStyle = matte;
        ctx.fillRect(0, 0, scaled.width, scaled.height);
      }
      ctx.scale(density, density);
      ctx.drawImage(src, 0, 0);
      return scaled;
    });
    var Format = class {
      constructor() {
        let png = "image/png", jpg = "image/jpeg", jpeg = "image/jpeg", webp = "image/webp";
        Object.assign(this, {
          toMime: this.toMime.bind(this),
          fromMime: this.fromMime.bind(this),
          expected: `"png", "jpg", or "webp"`,
          formats: { png, jpg, jpeg, webp },
          mimes: { [png]: "png", [jpg]: "jpg", [webp]: "webp" }
        });
      }
      toMime(ext) {
        return this.formats[(ext || "").replace(/^\./, "").toLowerCase()];
      }
      fromMime(mime) {
        return this.mimes[mime];
      }
    };
    function exportOptions(pages, { filename = "", extension = "", format, page, quality, matte, density, archive } = {}) {
      var { fromMime, toMime, expected } = new Format(), archive = archive || "canvas", ext = format || extension.replace(/@\d+x$/i, "") || (0, import_path.extname)(filename), format = fromMime(toMime(ext) || ext), mime = toMime(format), pp = pages.length;
      if (!ext) throw new Error(`Cannot determine image format (use a filename extension or 'format' argument)`);
      if (!format) throw new Error(`Unsupported file format "${ext}" (expected ${expected})`);
      if (!pp) throw new RangeError(`Canvas has no associated contexts (try calling getContext or newPage first)`);
      let padding, isSequence, pattern = filename.replace(/{(\d*)}/g, (_, width) => {
        isSequence = true;
        width = parseInt(width, 10);
        padding = isFinite(width) ? width : isFinite(padding) ? padding : -1;
        return "{}";
      });
      let idx = page > 0 ? page - 1 : page < 0 ? pp + page : void 0;
      if (isFinite(idx) && idx < 0 || idx >= pp) throw new RangeError(
        pp == 1 ? `Canvas only has a ‘page 1’ (${idx} is out of bounds)` : `Canvas has pages 1–${pp} (${idx} is out of bounds)`
      );
      pages = isFinite(idx) ? [pages[idx]] : isSequence || format == "pdf" ? pages : pages.slice(-1);
      if (quality === void 0) {
        quality = 0.92;
      } else {
        if (typeof quality != "number" || !isFinite(quality) || quality < 0 || quality > 1) {
          throw new TypeError("The quality option must be an number in the 0.0–1.0 range");
        }
      }
      if (density === void 0) {
        let m = (extension || (0, import_path.basename)(filename, ext)).match(/@(\d+)x$/i);
        density = m ? parseInt(m[1], 10) : 1;
      } else if (typeof density != "number" || !Number.isInteger(density) || density < 1) {
        throw new TypeError("The density option must be a non-negative integer");
      }
      return { filename, pattern, format, mime, pages, padding, quality, matte, density, archive };
    }
    var {
      CanvasRenderingContext2D,
      CanvasGradient,
      CanvasPattern,
      Image,
      ImageData,
      Path2D,
      DOMMatrix,
      DOMRect,
      DOMPoint
    } = window;
    module.exports = {
      Canvas,
      loadImage,
      loadImageData,
      CanvasRenderingContext2D,
      CanvasGradient,
      CanvasPattern,
      Image,
      ImageData,
      Path2D,
      DOMMatrix,
      DOMRect,
      DOMPoint
    };
  }
});
export default require_browser();
//# sourceMappingURL=skia-canvas.js.map
