{
  "version": 3,
  "sources": ["../../path-browserify/index.js", "../../skia-canvas/lib/browser.js"],
  "sourcesContent": ["// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n", "//\n// Browser equivalents of the skia-canvas convenience initializers and polyfills for\n// the Canvas object’s newPage & export methods\n//\n\n\"use strict\"\n\nconst _toURL_ = Symbol.for(\"toDataURL\")\n\nconst loadImage = src => {\n  let img = Object.assign(new Image(), {crossOrigin:'Anonymous', src})\n  return img.decode().then(() => img)\n}\n\nconst loadImageData = (src, width, height, settings) => fetch(src)\n  .then(resp => resp.arrayBuffer())\n  .then(buf => new ImageData(new Uint8ClampedArray(buf), width, height, settings))\n\nclass Canvas{\n  constructor(width, height){\n    let elt = document.createElement('canvas'),\n        pages = []\n\n    Object.defineProperty(elt, \"async\", {value:true, writable:false, enumerable:true})\n\n    for (var [prop, get] of Object.entries({\n      png: () => asBuffer(elt, 'image/png'),\n      jpg: () => asBuffer(elt, 'image/jpeg'),\n      pages: () => pages.concat(elt).map(c => c.getContext(\"2d\")),\n    })) Object.defineProperty(elt, prop, {get})\n\n    return Object.assign(elt, {\n      width, height,\n\n      newPage(...size){\n        var {width, height} = elt,\n            page = Object.assign(document.createElement('canvas'), {width, height})\n        page.getContext(\"2d\").drawImage(elt, 0, 0)\n        pages.push(page)\n\n        var [width, height] = size.length ? size : [width, height]\n        return Object.assign(elt, {width, height}).getContext(\"2d\")\n      },\n\n      saveAs(filename, args){\n        args = typeof args=='number' ? {quality:args} : args\n        let opts = exportOptions(this.pages, {filename, ...args}),\n            {pattern, padding, mime, quality, matte, density, archive} = opts,\n            pages = atScale(opts.pages, density);\n        return padding==undefined ? asDownload(pages[0], mime, quality, matte, filename)\n                                  : asZipDownload(pages, mime, quality, matte, archive, pattern, padding)\n      },\n\n      toBuffer(extension=\"png\", args={}){\n        args = typeof args=='number' ? {quality:args} : args\n        let opts = exportOptions(this.pages, {extension, ...args}),\n            {mime, quality, matte, pages, density} = opts,\n            canvas = atScale(pages, density, matte)[0]\n        return asBuffer(canvas, mime, quality, matte)\n      },\n\n      [_toURL_]: elt.toDataURL.bind(elt),\n      toDataURL(extension=\"png\", args={}){\n        args = typeof args=='number' ? {quality:args} : args\n        let opts = exportOptions(this.pages, {extension, ...args}),\n            {mime, quality, matte, pages, density} = opts,\n            canvas = atScale(pages, density, matte)[0],\n            url = canvas[canvas===elt ? _toURL_ : 'toDataURL'](mime, quality);\n        return Promise.resolve(url)\n      }\n    })\n  }\n}\n\n\n\n//\n// Zip (pace Phil Katz & q.v. https://github.com/jimmywarting/StreamSaver.js)\n//\n\nclass Crc32 {\n  static for(data){\n    return new Crc32().append(data).get()\n  }\n\n  constructor(){ this.crc = -1 }\n\n  get(){ return ~this.crc }\n\n  append(data){\n    var crc = this.crc | 0,\n        table = this.table\n    for (var offset = 0, len = data.length | 0; offset < len; offset++) {\n      crc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF]\n    }\n    this.crc = crc\n    return this\n  }\n\n}\n\nCrc32.prototype.table = (() => {\n  var i, j, t, table = []\n  for (i = 0; i < 256; i++) {\n    t = i\n    for (j = 0; j < 8; j++) {\n      t = (t & 1)\n        ? (t >>> 1) ^ 0xEDB88320\n        : t >>> 1\n    }\n    table[i] = t\n  }\n  return table\n})()\n\nfunction calloc(size){\n  let array = new Uint8Array(size),\n      view = new DataView(array.buffer),\n      buf = {\n        array, view, size,\n        set8(at, to){ view.setUint8(at, to); return buf },\n        set16(at, to){ view.setUint16(at, to, true); return buf },\n        set32(at, to){ view.setUint32(at, to, true); return buf },\n        bytes(at, to){ array.set(to, at); return buf },\n      }\n  return buf\n}\n\nclass Zip{\n  static encoder = new TextEncoder()\n\n  constructor(directory){\n    let now = new Date()\n    Object.assign(this, {\n      directory,\n      offset: 0,\n      files: [],\n      time: (((now.getHours() << 6) | now.getMinutes()) << 5) | now.getSeconds() / 2,\n      date: ((((now.getFullYear() - 1980) << 4) | (now.getMonth() + 1)) << 5) | now.getDate(),\n    })\n    this.add(directory)\n  }\n\n  async add(filename, blob){\n    let folder = !blob,\n        name = Zip.encoder.encode(`${this.directory}/${folder ? '' : filename}`),\n        data = new Uint8Array(folder ? 0 : await blob.arrayBuffer()),\n        preamble = 30 + name.length,\n        descriptor = preamble + data.length,\n        postamble = 16,\n        {offset} = this\n\n    let header = calloc(26)\n      .set32(0, 0x08080014)       // zip version\n      .set16(6, this.time)        // time\n      .set16(8, this.date)        // date\n      .set32(10, Crc32.for(data)) // checksum\n      .set32(14, data.length)     // compressed size (w/ zero compression)\n      .set32(18, data.length)     // un-compressed size\n      .set16(22, name.length)     // filename length (utf8 bytes)\n    offset += preamble\n\n    let payload = calloc(preamble + data.length + postamble)\n      .set32(0, 0x04034b50)   // local header signature\n      .bytes(4, header.array) // ...header fields...\n      .bytes(30, name)        // filename\n      .bytes(preamble, data)  // blob bytes\n    offset += data.length\n\n    payload\n      .set32(descriptor, 0x08074b50)                    // signature\n      .bytes(descriptor + 4, header.array.slice(10,22)) // length & filemame\n    offset += postamble\n\n    this.files.push({offset, folder, name, header, payload})\n    this.offset = offset\n  }\n\n  toBuffer(){\n    // central directory record\n    let length = this.files.reduce((len, {name}) => 46 + name.length + len, 0),\n        cdr = calloc(length + 22),\n        index = 0\n\n    for (var {offset, name, header, folder} of this.files){\n      cdr.set32(index, 0x02014b50)            // archive file signature\n         .set16(index + 4, 0x0014)            // version\n         .bytes(index + 6, header.array)      // ...header fields...\n         .set8(index + 38, folder ? 0x10 : 0) // is_dir flag\n         .set32(index + 42, offset)           // file offset\n         .bytes(index + 46, name)             // filename\n      index += 46 + name.length\n    }\n    cdr.set32(index, 0x06054b50)             // signature\n       .set16(index + 8, this.files.length)  // № files per-segment\n       .set16(index + 10, this.files.length) // № files this segment\n       .set32(index + 12, length)            // central directory length\n       .set32(index + 16, this.offset)       // file-offset of directory\n\n    // concatenated zipfile data\n    let output = new Uint8Array(this.offset + cdr.size),\n        cursor = 0;\n\n    for (var {payload} of this.files){\n      output.set(payload.array, cursor)\n      cursor += payload.size\n    }\n    output.set(cdr.array, cursor)\n\n    return output\n  }\n\n  get blob(){\n    return new Blob([this.toBuffer()], {type:\"application/zip\"})\n  }\n}\n\n\n//\n// Browser helpers for converting canvas elements to blobs/buffers/files/zips\n//\n\nconst asBlob = (canvas, mime, quality, matte) => {\n  if (matte){\n    let {width, height} = canvas,\n        comp = Object.assign(document.createElement('canvas'), {width, height}),\n        ctx = comp.getContext(\"2d\")\n    ctx.fillStyle = matte\n    ctx.fillRect(0, 0, width, height)\n    ctx.drawImage(canvas, 0, 0)\n    canvas = comp\n  }\n\n  return new Promise((res, rej) => canvas.toBlob(res, mime, quality))\n}\n\nconst asBuffer = (...args) => asBlob(...args).then(b => b.arrayBuffer())\n\nconst asDownload = async (canvas, mime, quality, matte, filename) => {\n  _download(filename, await asBlob(canvas, mime, quality, matte))\n}\n\nconst asZipDownload = async (pages, mime, quality, matte, archive, pattern, padding) => {\n  let filenames = i => pattern.replace('{}', String(i+1).padStart(padding, '0')),\n      folder = basename(archive, '.zip') || 'archive',\n      zip = new Zip(folder)\n\n  await Promise.all(pages.map(async (page, i) => {\n    let filename = filenames(i) // serialize filename(s) before awaiting\n    await zip.add(filename, await asBlob(page, mime, quality, matte))\n  }))\n\n  _download(`${folder}.zip`, zip.blob)\n}\n\nconst _download = (filename, blob) => {\n  const href = window.URL.createObjectURL(blob),\n        link = document.createElement('a')\n  link.style.display = 'none'\n  link.href = href\n  link.setAttribute('download', filename)\n  if (typeof link.download === 'undefined') {\n    link.setAttribute('target', '_blank')\n  }\n  document.body.appendChild(link)\n  link.click()\n  document.body.removeChild(link)\n  setTimeout(() => window.URL.revokeObjectURL(href), 100)\n}\n\nconst atScale = (pages, density, matte) => pages.map(page => {\n  if (density == 1 && !matte) return page.canvas\n\n  let scaled = document.createElement('canvas'),\n      ctx = scaled.getContext(\"2d\"),\n      src = page.canvas ? page.canvas : page\n  scaled.width = src.width * density\n  scaled.height = src.height * density\n  if (matte){\n    ctx.fillStyle = matte\n    ctx.fillRect(0, 0, scaled.width, scaled.height)\n  }\n  ctx.scale(density, density)\n  ctx.drawImage(src, 0, 0)\n  return scaled\n})\n\n//\n// Mime type <-> File extension mappings\n//\n\nclass Format{\n  constructor(){\n    let png = \"image/png\",\n        jpg = \"image/jpeg\",\n        jpeg = \"image/jpeg\",\n        webp = \"image/webp\"\n\n    Object.assign(this, {\n      toMime: this.toMime.bind(this),\n      fromMime: this.fromMime.bind(this),\n      expected: `\"png\", \"jpg\", or \"webp\"`,\n      formats: {png, jpg, jpeg, webp},\n      mimes: {[png]: \"png\", [jpg]: \"jpg\", [webp]: \"webp\"},\n    })\n  }\n\n  toMime(ext){\n    return this.formats[(ext||'').replace(/^\\./, '').toLowerCase()]\n  }\n\n  fromMime(mime){\n    return this.mimes[mime]\n  }\n}\n\n//\n// Validation of the options dict shared by the Canvas saveAs, toBuffer, and toDataURL methods\n//\n\nimport {basename, extname} from 'path'\n\nfunction exportOptions(pages, {filename='', extension='', format, page, quality, matte, density, archive}={}){\n  var {fromMime, toMime, expected} = new Format(),\n      archive = archive || 'canvas',\n      ext = format || extension.replace(/@\\d+x$/i,'') || extname(filename),\n      format = fromMime(toMime(ext) || ext),\n      mime = toMime(format),\n      pp = pages.length\n\n  if (!ext) throw new Error(`Cannot determine image format (use a filename extension or 'format' argument)`)\n  if (!format) throw new Error(`Unsupported file format \"${ext}\" (expected ${expected})`)\n  if (!pp) throw new RangeError(`Canvas has no associated contexts (try calling getContext or newPage first)`)\n\n  let padding, isSequence, pattern = filename.replace(/{(\\d*)}/g, (_, width) => {\n    isSequence = true\n    width = parseInt(width, 10)\n    padding = isFinite(width) ? width : isFinite(padding) ? padding : -1\n    return \"{}\"\n  })\n\n  // allow negative indexing if a specific page is specified\n  let idx = page > 0 ? page - 1\n          : page < 0 ? pp + page\n          : undefined;\n\n  if (isFinite(idx) && idx < 0 || idx >= pp) throw new RangeError(\n    pp == 1 ? `Canvas only has a ‘page 1’ (${idx} is out of bounds)`\n            : `Canvas has pages 1–${pp} (${idx} is out of bounds)`\n  )\n\n  pages = isFinite(idx) ? [pages[idx]]\n        : isSequence || format=='pdf' ? pages\n        : pages.slice(-1) // default to the 'current' context\n\n  if (quality===undefined){\n    quality = 0.92\n  }else{\n    if (typeof quality!='number' || !isFinite(quality) || quality<0 || quality>1){\n      throw new TypeError(\"The quality option must be an number in the 0.0–1.0 range\")\n    }\n  }\n\n  if (density===undefined){\n    let m = (extension || basename(filename, ext)).match(/@(\\d+)x$/i)\n    density = m ? parseInt(m[1], 10) : 1\n  }else if (typeof density!='number' || !Number.isInteger(density) || density<1){\n    throw new TypeError(\"The density option must be a non-negative integer\")\n  }\n\n  return {filename, pattern, format, mime, pages, padding, quality, matte, density, archive}\n}\n\n\nconst {CanvasRenderingContext2D, CanvasGradient, CanvasPattern,\n       Image, ImageData, Path2D, DOMMatrix, DOMRect, DOMPoint} = window;\n\nmodule.exports = {\n  Canvas, loadImage, loadImageData,\n  CanvasRenderingContext2D, CanvasGradient, CanvasPattern,\n  Image, ImageData, Path2D, DOMMatrix, DOMRect, DOMPoint\n}\n"],
  "mappings": "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",
  "names": ["width", "height", "pages", "name"]
}
